// DO NOT EDIT: this file is AUTOMATICALLY GENERATED and should not be changed.
#ifndef XLS_IR_NODES_
#define XLS_IR_NODES_

#include <cstdint>
#include <string>

#include "absl/status/statusor.h"
#include "absl/types/span.h"
#include "xls/ir/format_strings.h"
#include "xls/ir/lsb_or_msb.h"
#include "xls/ir/node.h"
#include "xls/ir/op.h"
#include "xls/ir/source_location.h"
#include "xls/ir/register.h"
#include "xls/ir/type.h"
#include "xls/ir/value.h"

namespace xls {

class Function;
class Instantiation;

struct SliceData {
  int64_t start;
  int64_t width;
};

class AfterAll : public Node {
 public:
  AfterAll(const SourceInfo& loc, absl::Span<Node* const> dependencies, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class Array : public Node {
 public:
  Array(const SourceInfo& loc, absl::Span<Node* const> elements, Type* element_type, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Type* element_type()  const 
     { return element_type_; }  
  
int64_t size()  const 
     { return operand_count(); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Type* element_type_;
};

class ArrayIndex : public Node {
 public:
  ArrayIndex(const SourceInfo& loc, Node* arg, absl::Span<Node* const> indices, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* array()  const 
     { return operand(0); }  
  
absl::Span<Node* const> indices()  const 
     { return operands().subspan(1); }  
  
};

class ArraySlice : public Node {
 public:
  ArraySlice(const SourceInfo& loc, Node* array, Node* start, int64_t width, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t width()  const 
     { return width_; }  
  
Node* array()  const 
     { return operand(0); }  
  
Node* start()  const 
     { return operand(1); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t width_;
};

class ArrayUpdate : public Node {
 public:
  ArrayUpdate(const SourceInfo& loc, Node* arg, Node* update_value, absl::Span<Node* const> indices, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* array_to_update()  const 
     { return operand(0); }  
  
absl::Span<Node* const> indices()  const 
     { return operands().subspan(2); }  
  
Node* update_value()  const 
     { return operand(1); }  
  
};

class ArrayConcat : public Node {
 public:
  ArrayConcat(const SourceInfo& loc, absl::Span<Node* const> args, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class BinOp : public Node {
 public:
  BinOp(const SourceInfo& loc, Node* lhs, Node* rhs, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class ArithOp : public Node {
 public:
  ArithOp(const SourceInfo& loc, Node* lhs, Node* rhs, int64_t width, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t width()  const 
     { return width_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t width_;
};

class PartialProductOp : public Node {
 public:
  PartialProductOp(const SourceInfo& loc, Node* lhs, Node* rhs, int64_t width, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t width()  const 
     { return width_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t width_;
};

class Assert : public Node {
 public:
  Assert(const SourceInfo& loc, Node* token, Node* condition, absl::string_view message, absl::optional<std::string> label, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
const std::string& message()  const 
     { return message_; }  
  
absl::optional<std::string> label()  const 
     { return label_; }  
  
Node* token()  const 
     { return operand(0); }  
  
Node* condition()  const 
     { return operand(1); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
std::string message_;
absl::optional<std::string> label_;
};

class Trace : public Node {
 public:
  Trace(const SourceInfo& loc, Node* token, Node* condition, absl::Span<Node* const> args, absl::Span<FormatStep const> format, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
absl::Span<FormatStep const> format()  const 
     { return format_; }  
  
Node* token()  const 
     { return operand(0); }  
  
Node* condition()  const 
     { return operand(1); }  
  
absl::Span<Node* const> args()  const 
     { return operands().subspan(2); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
std::vector<FormatStep> format_;
};

class Cover : public Node {
 public:
  Cover(const SourceInfo& loc, Node* token, Node* condition, absl::string_view label, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
const std::string& label()  const 
     { return label_; }  
  
Node* token()  const 
     { return operand(0); }  
  
Node* condition()  const 
     { return operand(1); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
std::string label_;
};

class BitwiseReductionOp : public Node {
 public:
  BitwiseReductionOp(const SourceInfo& loc, Node* operand, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class Receive : public Node {
 public:
  Receive(const SourceInfo& loc, Node* token, absl::optional<Node*> predicate, int64_t channel_id, bool is_blocking, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t channel_id()  const 
     { return channel_id_; }  
  
bool is_blocking()  const 
     { return is_blocking_; }  
  
Node* token()  const 
     { return operand(0); }  
  
absl::optional<Node*> predicate()  const 
     { return operand_count() > 1 ? absl::optional<Node*>(operand(1)) : absl::nullopt; }  
  
Type* GetPayloadType()  const 
  ; 

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t channel_id_;
bool is_blocking_;
};

class Send : public Node {
 public:
  Send(const SourceInfo& loc, Node* token, Node* data, absl::optional<Node*> predicate, int64_t channel_id, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t channel_id()  const 
     { return channel_id_; }  
  
Node* token()  const 
     { return operand(0); }  
  
Node* data()  const 
     { return operand(1); }  
  
absl::optional<Node*> predicate()  const 
     { return operand_count() > 2 ? absl::optional<Node*>(operand(2)) : absl::nullopt; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t channel_id_;
};

class NaryOp : public Node {
 public:
  NaryOp(const SourceInfo& loc, absl::Span<Node* const> args, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class BitSlice : public Node {
 public:
  BitSlice(const SourceInfo& loc, Node* arg, int64_t start, int64_t width, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t start()  const 
     { return start_; }  
  
int64_t width()  const 
     { return width_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t start_;
int64_t width_;
};

class DynamicBitSlice : public Node {
 public:
  DynamicBitSlice(const SourceInfo& loc, Node* arg, Node* start, int64_t width, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t width()  const 
     { return width_; }  
  
Node* to_slice()  const 
     { return operand(0); }  
  
Node* start()  const 
     { return operand(1); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t width_;
};

class BitSliceUpdate : public Node {
 public:
  BitSliceUpdate(const SourceInfo& loc, Node* arg, Node* start, Node* value, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* to_update()  const 
     { return operand(0); }  
  
Node* start()  const 
     { return operand(1); }  
  
Node* update_value()  const 
     { return operand(2); }  
  
};

class CompareOp : public Node {
 public:
  CompareOp(const SourceInfo& loc, Node* lhs, Node* rhs, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class Concat : public Node {
 public:
  Concat(const SourceInfo& loc, absl::Span<Node* const> args, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
SliceData GetOperandSliceData(int64_t operandno)  const 
  ; 
};

class CountedFor : public Node {
 public:
  CountedFor(const SourceInfo& loc, Node* initial_value, absl::Span<Node* const> invariant_args, int64_t trip_count, int64_t stride, Function* body, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t trip_count()  const 
     { return trip_count_; }  
  
int64_t stride()  const 
     { return stride_; }  
  
Function* body()  const 
     { return body_; }  
  
Node* initial_value()  const 
     { return operand(0); }  
  
absl::Span<Node* const> invariant_args()  const 
     { return operands().subspan(1); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t trip_count_;
int64_t stride_;
Function* body_;
};

class DynamicCountedFor : public Node {
 public:
  DynamicCountedFor(const SourceInfo& loc, Node* initial_value, Node* trip_count, Node* stride, absl::Span<Node* const> invariant_args, Function* body, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Function* body()  const 
     { return body_; }  
  
Node* initial_value()  const 
     { return operand(0); }  
  
Node* trip_count()  const 
     { return operand(1); }  
  
Node* stride()  const 
     { return operand(2); }  
  
absl::Span<Node* const> invariant_args()  const 
     { return operands().subspan(3); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Function* body_;
};

class ExtendOp : public Node {
 public:
  ExtendOp(const SourceInfo& loc, Node* arg, int64_t new_bit_count, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t new_bit_count()  const 
     { return new_bit_count_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t new_bit_count_;
};

class Invoke : public Node {
 public:
  Invoke(const SourceInfo& loc, absl::Span<Node* const> args, Function* to_apply, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Function* to_apply()  const 
     { return to_apply_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Function* to_apply_;
};

class Literal : public Node {
 public:
  Literal(const SourceInfo& loc, Value value, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
const Value& value()  const 
     { return value_; }  
  
bool IsZero()  const 
     { return value().IsBits() && value().bits().IsZero(); }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Value value_;
};

class Map : public Node {
 public:
  Map(const SourceInfo& loc, Node* arg, Function* to_apply, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Function* to_apply()  const 
     { return to_apply_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Function* to_apply_;
};

class OneHot : public Node {
 public:
  OneHot(const SourceInfo& loc, Node* input, LsbOrMsb priority, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
LsbOrMsb priority()  const 
     { return priority_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
LsbOrMsb priority_;
};

class OneHotSelect : public Node {
 public:
  OneHotSelect(const SourceInfo& loc, Node* selector, absl::Span<Node* const> cases, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* selector()  const 
     { return operand(0); }  
  
absl::Span<Node* const> cases()  const 
     { return operands().subspan(1); }  
  
Node* get_case(int64_t case_no)  const 
     { return cases().at(case_no); }  
  
};

class PrioritySelect : public Node {
 public:
  PrioritySelect(const SourceInfo& loc, Node* selector, absl::Span<Node* const> cases, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* selector()  const 
     { return operand(0); }  
  
absl::Span<Node* const> cases()  const 
     { return operands().subspan(1); }  
  
Node* get_case(int64_t case_no)  const 
     { return cases().at(case_no); }  
  
};

class Param : public Node {
 public:
  Param(const SourceInfo& loc, absl::string_view name, Type* type, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
absl::string_view name()  const 
     { return name_; }  
  
};

class Select : public Node {
 public:
  Select(const SourceInfo& loc, Node* selector, absl::Span<Node* const> cases, absl::optional<Node*> default_value, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* selector()  const 
     { return operand(0); }  
  
absl::Span<Node* const> cases()  const 
     { return operands().subspan(1, cases_size_); }  
  
Node* get_case(int64_t case_no)  const 
     { return cases().at(case_no); }  
  
absl::optional<Node*> default_value()  const 
     { return has_default_value_ ? absl::optional<Node*>(operands().back()) : absl::nullopt; }  
  
bool AllCases(std::function<bool(Node*)> p)  const 
  ; 
Node* any_case()  const 
     { return !cases().empty() ? cases().front() : default_value().has_value() ? default_value().value() : nullptr; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t cases_size_;
bool has_default_value_;
};

class Tuple : public Node {
 public:
  Tuple(const SourceInfo& loc, absl::Span<Node* const> elements, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t size()  const 
     { return operand_count(); }  
  
};

class TupleIndex : public Node {
 public:
  TupleIndex(const SourceInfo& loc, Node* arg, int64_t index, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t index()  const 
     { return index_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t index_;
};

class UnOp : public Node {
 public:
  UnOp(const SourceInfo& loc, Node* arg, Op op, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class Decode : public Node {
 public:
  Decode(const SourceInfo& loc, Node* arg, int64_t width, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
int64_t width()  const 
     { return width_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
int64_t width_;
};

class Encode : public Node {
 public:
  Encode(const SourceInfo& loc, Node* arg, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
};

class InputPort : public Node {
 public:
  InputPort(const SourceInfo& loc, absl::string_view name, Type* type, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
absl::string_view name()  const 
     { return name_; }  
  
};

class OutputPort : public Node {
 public:
  OutputPort(const SourceInfo& loc, Node* operand, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
absl::string_view name()  const 
     { return name_; }  
  
};

class RegisterRead : public Node {
 public:
  RegisterRead(const SourceInfo& loc, Register* reg, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Register* GetRegister()  const 
     { return reg_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Register* reg_;
};

class RegisterWrite : public Node {
 public:
  RegisterWrite(const SourceInfo& loc, Node* data, absl::optional<Node*> load_enable, absl::optional<Node*> reset, Register* reg, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* data()  const 
     { return operand(0); }  
  
absl::optional<Node*> load_enable()  const 
     { return has_load_enable_ ? absl::optional<Node*>(operand(1)) : absl::nullopt; }  
  
absl::optional<Node*> reset()  const 
     { return has_reset_ ? absl::optional<Node*>(operand(has_load_enable_ ? 2 : 1)) : absl::nullopt; }  
  
Register* GetRegister()  const 
     { return reg_; }  
  
absl::Status ReplaceExistingLoadEnable(Node* new_operand)  
     { return has_load_enable_ ? ReplaceOperandNumber(1, new_operand) : absl::InternalError("Unable to replace load enable on RegisterWrite -- register does not have an existing load enable operand."); }  
  
absl::Status AddOrReplaceReset(Node* new_reset_node, Reset new_reset_info)  
     { 
                            reg_->UpdateReset(new_reset_info);
                            if(!has_reset_) {
                              AddOperand(new_reset_node);
                              has_reset_ = true;
                              return absl::OkStatus();
                            }
                            return has_load_enable_ ? ReplaceOperandNumber(2, new_reset_node) : ReplaceOperandNumber(1, new_reset_node);
                           } 
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Register* reg_;
bool has_load_enable_;
bool has_reset_;
};

class InstantiationOutput : public Node {
 public:
  InstantiationOutput(const SourceInfo& loc, Instantiation* instantiation, absl::string_view port_name, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Instantiation* instantiation()  const 
     { return instantiation_; }  
  
const std::string& port_name()  const 
     { return port_name_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Instantiation* instantiation_;
std::string port_name_;
};

class InstantiationInput : public Node {
 public:
  InstantiationInput(const SourceInfo& loc, Node* data, Instantiation* instantiation, absl::string_view port_name, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Instantiation* instantiation()  const 
     { return instantiation_; }  
  
const std::string& port_name()  const 
     { return port_name_; }  
  

  bool IsDefinitelyEqualTo(const Node* other) const override;

 private:
Instantiation* instantiation_;
std::string port_name_;
};

class Gate : public Node {
 public:
  Gate(const SourceInfo& loc, Node* condition, Node* data, absl::string_view name, FunctionBase* function);

  absl::StatusOr<Node*> CloneInNewFunction(
    absl::Span<Node* const> new_operands,
    FunctionBase* new_function) const override;
Node* condition()  const 
     { return operand(0); }  
  
Node* data()  const 
     { return operand(1); }  
  
};



}  // namespace xls

#endif  // XLS_IR_NODES_
