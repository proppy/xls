// DO NOT EDIT: this file is AUTOMATICALLY GENERATED and should not be changed.
#ifndef XLS_IR_OP_
#define XLS_IR_OP_

#include <cstdint>
#include <string>
#include <vector>

#include "absl/strings/string_view.h"
#include "absl/types/span.h"
#include "absl/status/statusor.h"
#include "xls/ir/op.pb.h"

namespace xls {

// Enumerates the operator for nodes in the IR.
enum class Op {
  kAdd,
  kAnd,
  kAndReduce,
  kAssert,
  kCover,
  kReceive,
  kSend,
  kNand,
  kNor,
  kAfterAll,
  kArray,
  kArrayIndex,
  kArraySlice,
  kArrayUpdate,
  kArrayConcat,
  kBitSlice,
  kDynamicBitSlice,
  kBitSliceUpdate,
  kConcat,
  kCountedFor,
  kDecode,
  kDynamicCountedFor,
  kEncode,
  kEq,
  kIdentity,
  kInvoke,
  kInputPort,
  kLiteral,
  kMap,
  kNe,
  kNeg,
  kNot,
  kOneHot,
  kOneHotSel,
  kPrioritySel,
  kOr,
  kOrReduce,
  kOutputPort,
  kParam,
  kRegisterRead,
  kRegisterWrite,
  kInstantiationOutput,
  kInstantiationInput,
  kReverse,
  kSDiv,
  kSMod,
  kSel,
  kSGe,
  kSGt,
  kShll,
  kShrl,
  kShra,
  kSignExt,
  kSLe,
  kSLt,
  kSMul,
  kSMulp,
  kSub,
  kTuple,
  kTupleIndex,
  kUDiv,
  kUMod,
  kUGe,
  kUGt,
  kULe,
  kULt,
  kUMul,
  kUMulp,
  kXor,
  kXorReduce,
  kZeroExt,
  kGate,
  kTrace,
  };

inline std::vector<Op> AllOps() {
  return {
  Op::kAdd,
  Op::kAnd,
  Op::kAndReduce,
  Op::kAssert,
  Op::kCover,
  Op::kReceive,
  Op::kSend,
  Op::kNand,
  Op::kNor,
  Op::kAfterAll,
  Op::kArray,
  Op::kArrayIndex,
  Op::kArraySlice,
  Op::kArrayUpdate,
  Op::kArrayConcat,
  Op::kBitSlice,
  Op::kDynamicBitSlice,
  Op::kBitSliceUpdate,
  Op::kConcat,
  Op::kCountedFor,
  Op::kDecode,
  Op::kDynamicCountedFor,
  Op::kEncode,
  Op::kEq,
  Op::kIdentity,
  Op::kInvoke,
  Op::kInputPort,
  Op::kLiteral,
  Op::kMap,
  Op::kNe,
  Op::kNeg,
  Op::kNot,
  Op::kOneHot,
  Op::kOneHotSel,
  Op::kPrioritySel,
  Op::kOr,
  Op::kOrReduce,
  Op::kOutputPort,
  Op::kParam,
  Op::kRegisterRead,
  Op::kRegisterWrite,
  Op::kInstantiationOutput,
  Op::kInstantiationInput,
  Op::kReverse,
  Op::kSDiv,
  Op::kSMod,
  Op::kSel,
  Op::kSGe,
  Op::kSGt,
  Op::kShll,
  Op::kShrl,
  Op::kShra,
  Op::kSignExt,
  Op::kSLe,
  Op::kSLt,
  Op::kSMul,
  Op::kSMulp,
  Op::kSub,
  Op::kTuple,
  Op::kTupleIndex,
  Op::kUDiv,
  Op::kUMod,
  Op::kUGe,
  Op::kUGt,
  Op::kULe,
  Op::kULt,
  Op::kUMul,
  Op::kUMulp,
  Op::kXor,
  Op::kXorReduce,
  Op::kZeroExt,
  Op::kGate,
  Op::kTrace,
  };
}

const int64_t kOpLimit = static_cast<int64_t>(Op::kTrace)+1;

// Converts an OpProto into an Op.
Op FromOpProto(OpProto op_proto);

// Converts an Op into an OpProto.
OpProto ToOpProto(Op op);

// Converts the "op" enumeration to a human readable string.
std::string OpToString(Op op);

// Converts a human readable op string into the "op" enumeration.
absl::StatusOr<Op> StringToOp(absl::string_view op_str);

// Returns whether the operation is a compare operation.
bool OpIsCompare(Op op);

// Returns whether the operation is associative, eg., kAdd, or kOr.
bool OpIsAssociative(Op op);

// Returns whether the operation is commutative, eg., kAdd, or kEq.
bool OpIsCommutative(Op op);

// Returns whether the operation is a bitwise logical op, eg., kAnd or kOr.
bool OpIsBitWise(Op op);

// Returns whether the operation has side effects, eg., kAssert, kSend.
bool OpIsSideEffecting(Op op);

// Returns the delay of this operation in picoseconds.
// TODO(meheff): This value should be plugable and be derived from other aspects
// of Node, not just the op.
int64_t OpDelayInPs(Op op);

// Forward declare all Op classes (subclasses of Node).
class AfterAll;
class Array;
class ArrayIndex;
class ArraySlice;
class ArrayUpdate;
class ArrayConcat;
class BinOp;
class ArithOp;
class PartialProductOp;
class Assert;
class Trace;
class Cover;
class BitwiseReductionOp;
class Receive;
class Send;
class NaryOp;
class BitSlice;
class DynamicBitSlice;
class BitSliceUpdate;
class CompareOp;
class Concat;
class CountedFor;
class DynamicCountedFor;
class ExtendOp;
class Invoke;
class Literal;
class Map;
class OneHot;
class OneHotSelect;
class PrioritySelect;
class Param;
class Select;
class Tuple;
class TupleIndex;
class UnOp;
class Decode;
class Encode;
class InputPort;
class OutputPort;
class RegisterRead;
class RegisterWrite;
class InstantiationOutput;
class InstantiationInput;
class Gate;


// Returns whether the given Op has the OpT node subclass.
class Node;

template<typename OpT>
bool IsOpClass(Op op) {
  static_assert(std::is_base_of<Node, OpT>::value, "OpT is not a Node subclass");
  return false;
}

template<>
bool IsOpClass<AfterAll>(Op op);
template<>
bool IsOpClass<Array>(Op op);
template<>
bool IsOpClass<ArrayIndex>(Op op);
template<>
bool IsOpClass<ArraySlice>(Op op);
template<>
bool IsOpClass<ArrayUpdate>(Op op);
template<>
bool IsOpClass<ArrayConcat>(Op op);
template<>
bool IsOpClass<BinOp>(Op op);
template<>
bool IsOpClass<ArithOp>(Op op);
template<>
bool IsOpClass<PartialProductOp>(Op op);
template<>
bool IsOpClass<Assert>(Op op);
template<>
bool IsOpClass<Trace>(Op op);
template<>
bool IsOpClass<Cover>(Op op);
template<>
bool IsOpClass<BitwiseReductionOp>(Op op);
template<>
bool IsOpClass<Receive>(Op op);
template<>
bool IsOpClass<Send>(Op op);
template<>
bool IsOpClass<NaryOp>(Op op);
template<>
bool IsOpClass<BitSlice>(Op op);
template<>
bool IsOpClass<DynamicBitSlice>(Op op);
template<>
bool IsOpClass<BitSliceUpdate>(Op op);
template<>
bool IsOpClass<CompareOp>(Op op);
template<>
bool IsOpClass<Concat>(Op op);
template<>
bool IsOpClass<CountedFor>(Op op);
template<>
bool IsOpClass<DynamicCountedFor>(Op op);
template<>
bool IsOpClass<ExtendOp>(Op op);
template<>
bool IsOpClass<Invoke>(Op op);
template<>
bool IsOpClass<Literal>(Op op);
template<>
bool IsOpClass<Map>(Op op);
template<>
bool IsOpClass<OneHot>(Op op);
template<>
bool IsOpClass<OneHotSelect>(Op op);
template<>
bool IsOpClass<PrioritySelect>(Op op);
template<>
bool IsOpClass<Param>(Op op);
template<>
bool IsOpClass<Select>(Op op);
template<>
bool IsOpClass<Tuple>(Op op);
template<>
bool IsOpClass<TupleIndex>(Op op);
template<>
bool IsOpClass<UnOp>(Op op);
template<>
bool IsOpClass<Decode>(Op op);
template<>
bool IsOpClass<Encode>(Op op);
template<>
bool IsOpClass<InputPort>(Op op);
template<>
bool IsOpClass<OutputPort>(Op op);
template<>
bool IsOpClass<RegisterRead>(Op op);
template<>
bool IsOpClass<RegisterWrite>(Op op);
template<>
bool IsOpClass<InstantiationOutput>(Op op);
template<>
bool IsOpClass<InstantiationInput>(Op op);
template<>
bool IsOpClass<Gate>(Op op);


// Streams the string for "op" to the given output stream.
std::ostream& operator<<(std::ostream& os, Op op);

}  // namespace xls

#endif  // XLS_IR_OP_
